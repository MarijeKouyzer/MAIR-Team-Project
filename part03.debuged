def remove_brackets(word):
    return_word = word
    print("in remove brackets ", return_word)
    # print(return_word[0])
    # print(return_word[(len(word)-1)])
    if return_word[0] == "(":
        # print("must remove ( from ", return_word)
        return_word = return_word[1::]
    if return_word[(len(return_word)-1)] == ")":
        # print("must remove ) from ", return_word)
        # return_word = return_word[::-1] <- I think this is logically incorrect
        return_word = return_word[:-1]
    print(return_word, " is returned")
    return return_word


class Node:
    text: str
    type: str

    children: list = []
    parent = None
    return_type = ""
    # 0 or 1
    return_rule = 1

    def add_child(self, child):
        self.children.append(child)

    def is_compatible_with(self, right):
        print("*******************")
        print("node.self: ", self.text)
        print("right ",right.text )
        print("*******************")
        right__type_split = right.type.rsplit("\\", 1)
        print("Right type s: ", right__type_split)
        expected_left_type = right__type_split[0]
        if self.type == expected_left_type:
            print("\\ split branch self.type: ", self.type)
            print("expected left type ",expected_left_type)
            self.return_type = remove_brackets(right__type_split[1])
            self.return_rule = 0
            return True

        left__type_split = self.type.rsplit("/", 1)
        print("Left type s: ", left__type_split)
        if len(left__type_split) == 2:
            expected_right_type = left__type_split[1]
            print("/ split branch, expected_right_type: ",expected_right_type)
            if right.type == expected_right_type:
                print("right.type == expected_right_type, expected_right_type[0]: ", expected_right_type[0])
                # self.return_type = remove_brackets(expected_right_type[0]) <- This line might be logically wrong
                self.return_type = remove_brackets(left__type_split[0])
                self.return_rule = 1
                print("self.retype: ", self.return_type)
                return True
        print("False returned")
        return False

    def print(self):
        print(self.type + "\n")
        print(self.text + "\n")
        for child in self.children:
            child.print()


rules = {
    'i': "np",
    "want": "(np\s)/np",
    "a": "np/np",
    "restaurant": "np",
    "serving": "(s\s)/np",
    "swedish": "np/np",
    "food": "np"
}
variable_types = {
    "area": {
        "keywords": ["town", "of"],
        "words": ["east", "west", "north", "south", "centre"]
    },
    "price_range": {
        "keywords": ["restaurant", "price"],
        "words": ["moderate", "expensive", "cheap"]
    },
    "food": {
        "keywords": ["restaurant", "serves", "serving", "food"],
        "words": ["thai", "turkish", "european", "catalan", "mediterranean", "seafood", "british", "modern european", "italian", "romanian", "chinese", "steakhouse", "asian oriental", "french", "portuguese", "indian", "spanish", "vietnamese", "korean", "moroccan", "swiss", "fusion", "gastropub", "tuscun", "international", "traditional", "mediterranean", "poynesian", "african", "turkish", "bistro", "north american", "australasian", "persian", "jamaican", "lebanese", "cubun", "japenese", "catalan"]
    }
}
variable_nodes = dict()


def evaluate_word_list(nodes: list) -> Node:
    tree_node = Node()
    new_nodes = list()
    ori_nodes = nodes

    # i want a restaurant serving swedish food
    # i = 0
    # for node in ori_nodes:
    #     if i != len(nodes):
    #         print("check i: %s", i)
    #         if i + 1 < len(nodes):
    #             if node.is_compatible_with(nodes[i+1]):
    #                 print(i, " is compatible")
    #                 print(node.text, " ", node.return_type)
    #                 new_node = Node()
    #                 new_node.type = node.return_type
    #                 new_node.text = node.text + " " + nodes[i+1].text
    #                 print("new node", new_node.type, " ", new_node.text)
    #                 new_node.children.append(node)
    #                 new_node.children.append(nodes[i+1])
    #                 node.parent = new_node
    #                 nodes[i+1].parent = new_node
    #                 new_nodes.append(new_node)
    #             else:
    #                 new_nodes.append(node)
    #     else:
    #         new_nodes.append(node)
    #     i += 1

    # Pseudo algorithm here
    # while len(nodes)!=1
    #     i=0
    #     structure_changed = False
    #     while i<len(nodes)-1
    #       do is_compatible from left to right in nodes in nodes[0:len(nodes)-1]
    #       if node is compatible
    #           structure_changed = True
    #           put combined new type in new node list
    #       else
    #           put node in new node list
    #       i++
    #     if i== len(nodes - 1) && structure_changed == True
    #       create new candidates by nodes = new_node_list
    #     if i== len(nodes - 1) && structure_changed == False
    #         break
    #     i +=1

    print("ASDASDSADDA")
    print(len(ori_nodes))

    global i
    global structure_changed
    i = 0
    structure_changed = False
    while len(ori_nodes) != 1:
        i = 0
        structure_changed = False
        while i <= len(ori_nodes)-1:
            if i < len(ori_nodes)-1:
                if ori_nodes[i].is_compatible_with(ori_nodes[i + 1]):
                    print(i, " is compatible")
                    print(ori_nodes[i].text, " ", ori_nodes[i].return_type)
                    new_node = Node()
                    new_node.type = ori_nodes[i].return_type
                    new_node.text = ori_nodes[i].text + " " + ori_nodes[i+1].text
                    print("new node!", new_node.type, " text: ", new_node.text)
                    new_node.children.append(ori_nodes[i])
                    new_node.children.append(ori_nodes[i+1])
                    ori_nodes[i].parent = new_node
                    ori_nodes[i+1].parent = new_node
                    new_nodes.append(new_node)

                    structure_changed = True
                    if ori_nodes[i].return_rule == 1:
                        print("%%%%%%%%%%% slash 1 rule %%%%%%%%%%%%")
                        i = i+1
                    if ori_nodes[i].return_rule == 0:
                        print("%%%%%%%%%%% slash 0 rule %%%%%%%%%%%%")
                        i = i + 1
                else:
                    print(i, " is not compatible")
                    new_nodes.append(ori_nodes[i])
            else:
                print(i, " is not compatible")
                new_nodes.append(ori_nodes[i])
            i = i + 1

        if structure_changed is True:
            # create new candidates by nodes = new_node_list
            print("structure changed")
            print("#################################")
            print("New nodes")
            for new in new_nodes:
                print(new.text)
            print("new  node length")
            print(len(new_nodes))
            print("#################################")
            ori_nodes = new_nodes
            new_nodes = list()
            # print("ori node check")
            # for n in ori_nodes:
            #     print(n.text)
            # print("ori  node length")
            # print(len(ori_nodes))
        if structure_changed is False:
            print("structure not changed")
            break
        # i = i + 1
    print("!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print("Final nodes")
    for new in ori_nodes :
        print(new.text)
    print("Final length")
    print(len(ori_nodes))
    tree_is_complete = len(ori_nodes) == 1
    if tree_is_complete:
        print("Tree is complete")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        tree_node = ori_nodes[0]
        return tree_node
    if structure_changed is False or tree_is_complete is False:
        print("Nothing change or and tree is not complete")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        return tree_node
    return Node()


def build_tree(text: str) -> Node:
    # Change the text into a list of nodes containing the word and the type
    word_list = text.split(" ")
    node_list = list()
    # print(word_list)
    for word in word_list:
        word_node = Node()
        word_node.text = word
        if word in rules.keys():
            word_node.type = rules[word]
        else:
            word_node.type = "np"
        node_list.append(word_node)
    # Return the tree
    # print(node_list[1].text)
    return evaluate_word_list(node_list)


def find_variables_in_branch(node, variable_type):
    # Node is a leaf
    if len(node.children) == 0:
        if node.text in variable_types[variable_type]["words"]:
            variable_nodes[variable_type] = node
    # If not, continue to the children
    else:
        for child in node.children:
            find_variables_in_branch(child, variable_type)


def traverse_tree(node):
    # See if there are multiple variable types in the sub(tree)
    variable_types_in_text = list()
    word_list = node.text.split(" ")
    for variable_type, v_value in variable_types.items():
        for word in word_list:
            if word in v_value["keywords"]:
                variable_types_in_text.append(variable_types)
    if len(variable_types_in_text) == 1:
        # The node is a node containing a single type of variable
        find_variables_in_branch(node, variable_types_in_text[0])
        return
    # Make sure we don't traverse when not necessary
    if len(variable_types_in_text) == 0:
        return
    for child in node.children:
        traverse_tree(child)


# Wait for input
while True:
    user_text = input("Enter text to evaluate: ")
    root_node = build_tree(user_text)
    variable_nodes = dict()
    print("The root node will be ", root_node.text)
    traverse_tree(root_node)
    root_node.print()
    print("\n---------\n")
    print("VARIABLES\n")
    print("---------\n")
    print("---------")
    for key, value in variable_nodes.items():
         print("---------\n")
         print(key + "\n")
         value.print()
